


Cloll
be
Kubernetes
and
below:

update.
update.
update.

Manager)
Kubernetes
releases
us.

Started

er [here](docs/getting-started.md)!

_Note that this CCM is installed by default on [DOKS](https://www.digitalocean.com/products/kubernetes/) (DigitalOcean Managed Kubernetes), you don't have to do it yourself._

## Examples

Here are some examples of how you could leverage `digitalocean-cloud-controller-manager`:

* [loadbalancers](docs/controllers/services/examples/)
* [node labels and addresses](docs/controllers/node/examples/)

## Production notes

### do not modify DO load-balancers manually

When creating load-balancers through CCM (via `LoadBalancer`-typed Services), it is important that you **must not change the DO load-balancer configuration manually.** Such changes will eventually be reverted by the reconciliation loop built into CCM. One exception are load-balancer names which can be changed (see also [the documentation on load-balancer ID annotations](/docs/getting-started.md#load-balancer-id-annotations)).

Other than that, the only safe place to make load-balancer configuration changes is through the Service object.

### DO load-balancer entry port restrictions

For technical reasons, the ports 50053, 50054, and 50055 cannot be used as load-balancer entry ports (i.e., the port that the load-balancer listens on for requests). Trying to use one of the affected ports as service port causes a _422 entry port is invalid_ HTTP error response to be returned by the DO API (and surfaced as a Kubernetes event).

The solution is to change the service port to a different, non-conlicting one.

## Development

### Basics

* Go: min `v1.12.x`

This project uses [Go modules](https://github.com/golang/go/wiki/Modules) for dependency management and employs vendoring. Please ensure to run `make vendor` after any dependency modifications.

After making your code changes, run the tests and CI checks:

```bash
make ci
```

### Run Locally

If you want to run `digitalocean-cloud-controller-manager` locally against a
particular cluster, keep your kubeconfig ready and start the binary in the main
package-hosted directory like this:

```bash
cd cloud-controller-manager/cmd/digitalocean-cloud-controller-manager
FAKE_REGION=fra1 DO_ACCESS_TOKEN=your_access_token go run main.go \
  --kubeconfig <path to your kubeconfig file>                     \
  --leader-elect=false --v=5 --cloud-provider=digitalocean
```

The `FAKE_REGION` environment variable takes a (valid) DigitalOcean region. It
is needed to keep `digitalocean-cloud-controller-manager` from trying to access
the DigitalOcean metadata service which is only available on droplets. Overall,
which region you choose should not matter a lot as long as you pick one.

You might also need to provide your DigitalOcean access token in
`DO_ACCESS_TOKEN` environment variable. The token does not need to be valid for
the cloud controller to start, but in that case you will not be able to
validate integration with DigitalOcean API.

Please note that if you use a kubernetes cluster created on DigitalOcean, there
will be a cloud controller manager running in the cluster already, so you local
one will compete for API access with it.

### Run Locally (optional features)

#### Add Public Access Firewall

If you want to add an additional firewall, that allows public access to your
cluster, you can run a command like this:

```bash
cd cloud-controller-manager/cmd/digitalocean-cloud-controller-manager
FAKE_REGION=fra1 DO_ACCESS_TOKEN=your_access_token            \
PUBLIC_ACCESS_FIREWALL_NAME=firewall_name                     \
PUBLIC_ACCESS_FIREWALL_TAGS=k8s,k8s:<cluster-uuid>,k8s:worker \
go run main.go                                                \
  --kubeconfig <path to your kubeconfig file>                 \                                     
  --leader-elect=false --v=5 --cloud-provider=digitalocean
```

The `PUBLIC_ACCESS_FIREWALL_NAME` environment variable allows you to pass in
the name of the firewall you plan to use in addition to the already existing
DOKS managed firewall. It is called public access because you are able to
allow access to ports in the NodePort range, whereas this isn't possible with
the default DOKS managed firewall. Not passing this in will cause your cluster
to resort to the default behavior of denying all 

The `METRICS_ADDR` environment variable takes a valid endpoint that you'd
like to use to serve your prometheus metrics. To be valid it should be in the
form `<host>:<port>`.

After you have started up CCM, run the following curl command to view the
prometheus metrics output:

```bash
curl <host>:<port>/metrics
```

### Run Containerized

If you want to test your changes in a containerized environment, create a new
image with the version set to `dev`:

```bash
VERSION=dev make publish
```

Th
